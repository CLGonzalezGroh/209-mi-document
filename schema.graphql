extend schema
  @link(
    url: "https://specs.apollo.dev/federation/v2.7"
    import: ["@key", "@shareable"]
  )

"Tipo de dato para representar una fecha y hora"
scalar DateTime

"Recupera el nombre de usuario"
type UserName @key(fields: "id") {
  id: Int
}

"Empresa para darle seguimiento comercial"
type Company @key(fields: "id") {
  id: Int!
}

# ═══════════════════════════════════════════════════════
# ENUMS
# ═══════════════════════════════════════════════════════

"Módulos de la aplicación"
enum ModuleType {
  "Calidad"
  QUALITY
  "Proyectos"
  PROJECTS
  "Tags / Equipos"
  TAGS
  "Operaciones"
  OPERATIONS
  "Gestión"
  MANAGEMENT
  "Comercial"
  COMERCIAL
}

"Esquema de revisión del documento"
enum RevisionScheme {
  "Alfabético: A, B, C, ..., Z, AA, AB, ..."
  ALPHABETICAL
  "Numérico: 0, 1, 2, 3, ..."
  NUMERIC
}

"Estado de las revisiones de un documento"
enum RevisionStatus {
  "En borrador, se pueden subir nuevas versiones"
  DRAFT
  "Enviado a workflow de revisión"
  IN_REVIEW
  "Aprobado, no se puede modificar"
  APPROVED
  "Reemplazado por una nueva revisión"
  SUPERSEDED
  "Obsoleto, ya no aplica"
  OBSOLETE
}

"Estado del workflow de revisión"
enum WorkflowStatus {
  "Creado pero no iniciado"
  PENDING
  "Al menos un step en proceso"
  IN_PROGRESS
  "Todos los steps aprobados"
  COMPLETED
  "Al menos un step rechazado"
  REJECTED
}

"Tipo de paso en el workflow de revisión"
enum StepType {
  "Revisión técnica"
  REVIEW
  "Aprobación formal"
  APPROVE
  "Toma de conocimiento"
  ACKNOWLEDGE
}

"Estado de un paso del workflow"
enum StepStatus {
  "No evaluado aún"
  PENDING
  "Aprobado por el asignado"
  APPROVED
  "Rechazado por el asignado"
  REJECTED
  "Saltado"
  SKIPPED
}

"Estado del transmittal"
enum TransmittalStatus {
  "En preparación"
  DRAFT
  "Enviado al cliente"
  ISSUED
  "Cliente acusó recibo"
  ACKNOWLEDGED
  "Cliente respondió con comentarios"
  RESPONDED
  "Cerrado"
  CLOSED
}

"Código de propósito del envío"
enum PurposeCode {
  "Para aprobación del cliente"
  FOR_APPROVAL
  "Solo informativo"
  FOR_INFORMATION
  "Aprobado para construcción"
  FOR_CONSTRUCTION
  "Para revisión y comentarios"
  FOR_REVIEW
  "Documentación as-built"
  AS_BUILT
}

"Estado de respuesta del cliente"
enum ClientStatus {
  "Aprobado sin comentarios"
  APPROVED
  "Aprobado con comentarios"
  APPROVED_WITH_COMMENTS
  "Rechazado"
  REJECTED
  "Revisado sin objeción"
  REVIEWED_NO_EXCEPTION
}

"Módulos de la aplicación para inputs"
enum ModuleTypeInput {
  "Calidad"
  QUALITY
  "Proyectos"
  PROJECTS
  "Tags / Equipos"
  TAGS
  "Operaciones"
  OPERATIONS
  "Gestión"
  MANAGEMENT
  "Comercial"
  COMERCIAL
}

"Esquema de revisión para inputs"
enum RevisionSchemeInput {
  "Alfabético: A, B, C, ..., Z, AA, AB, ..."
  ALPHABETICAL
  "Numérico: 0, 1, 2, 3, ..."
  NUMERIC
}

"Estado de las revisiones para inputs"
enum RevisionStatusInput {
  "En borrador"
  DRAFT
  "En revisión"
  IN_REVIEW
  "Aprobado"
  APPROVED
  "Reemplazado"
  SUPERSEDED
  "Obsoleto"
  OBSOLETE
}

"Estado del workflow para inputs"
enum WorkflowStatusInput {
  "Pendiente"
  PENDING
  "En progreso"
  IN_PROGRESS
  "Completado"
  COMPLETED
  "Rechazado"
  REJECTED
}

"Tipo de paso del workflow para inputs"
enum StepTypeInput {
  "Revisión técnica"
  REVIEW
  "Aprobación formal"
  APPROVE
  "Toma de conocimiento"
  ACKNOWLEDGE
}

"Estado del transmittal para inputs"
enum TransmittalStatusInput {
  "En preparación"
  DRAFT
  "Enviado al cliente"
  ISSUED
  "Cliente acusó recibo"
  ACKNOWLEDGED
  "Cliente respondió con comentarios"
  RESPONDED
  "Cerrado"
  CLOSED
}

"Código de propósito para inputs"
enum PurposeCodeInput {
  "Para aprobación del cliente"
  FOR_APPROVAL
  "Solo informativo"
  FOR_INFORMATION
  "Aprobado para construcción"
  FOR_CONSTRUCTION
  "Para revisión y comentarios"
  FOR_REVIEW
  "Documentación as-built"
  AS_BUILT
}

"Estado de respuesta del cliente para inputs"
enum ClientStatusInput {
  "Aprobado sin comentarios"
  APPROVED
  "Aprobado con comentarios"
  APPROVED_WITH_COMMENTS
  "Rechazado"
  REJECTED
  "Revisado sin objeción"
  REVIEWED_NO_EXCEPTION
}

"Estado de los registros a filtrar utilizando el campo terminatedAt"
enum TerminatedFilterInput {
  "Todos los registros"
  ALL
  "Registros habilitados o activos"
  ACTIVE
  "Registros deshabilitados o inactivos"
  DISABLED
}

"Dirección del ordenamiento"
enum SortDirectionInput {
  "Ascendente"
  ASC
  "Descendente"
  DESC
}

"Campos de ordenamiento para documentos"
enum DocumentOrderFieldInput {
  "Por código"
  CODE
  "Por título"
  TITLE
  "Por fecha de creación"
  CREATED_AT
  "Por fecha de actualización"
  UPDATED_AT
  "Por módulo"
  MODULE
}

"Campos de ordenamiento para tipos de documento"
enum DocumentTypeOrderFieldInput {
  "Por nombre"
  NAME
  "Por código"
  CODE
  "Por fecha de creación"
  CREATED_AT
  "Por fecha de actualización"
  UPDATED_AT
}

"Campos de ordenamiento para transmittals"
enum TransmittalOrderFieldInput {
  "Por código"
  CODE
  "Por fecha de creación"
  CREATED_AT
  "Por fecha de emisión"
  ISSUED_AT
  "Por estado"
  STATUS
}

"Estado de clasificación digital del archivo escaneado"
enum DigitalDisposition {
  "Pendiente de clasificación"
  PENDING
  "Aceptado, pendiente de carga en sistema externo"
  ACCEPTED
  "Cargado en sistema externo, ciclo cerrado"
  UPLOADED
  "Descartado, sin valor documental"
  DISCARDED
}

"Estado de clasificación digital para inputs"
enum DigitalDispositionInput {
  "Pendiente de clasificación"
  PENDING
  "Aceptado, pendiente de carga en sistema externo"
  ACCEPTED
  "Cargado en sistema externo, ciclo cerrado"
  UPLOADED
  "Descartado, sin valor documental"
  DISCARDED
}

"Disposición física del papel original"
enum PhysicalDisposition {
  "Pendiente de decisión"
  PENDING
  "Programado para destrucción"
  DESTROY
  "Destrucción confirmada"
  DESTROYED
  "Programado para almacenamiento físico"
  ARCHIVE
  "Almacenamiento confirmado"
  ARCHIVED
}

"Disposición física para inputs"
enum PhysicalDispositionInput {
  "Pendiente de decisión"
  PENDING
  "Programado para destrucción"
  DESTROY
  "Destrucción confirmada"
  DESTROYED
  "Programado para almacenamiento físico"
  ARCHIVE
  "Almacenamiento confirmado"
  ARCHIVED
}

"Campos de ordenamiento para archivos escaneados"
enum ScannedFileOrderFieldInput {
  "Por título"
  TITLE
  "Por fecha de creación"
  CREATED_AT
  "Por fecha de clasificación"
  CLASSIFIED_AT
  "Por disposición digital"
  DIGITAL_DISPOSITION
}

"Nivel del log"
enum LogLevel {
  "Información"
  INFO
  "Advertencia"
  WARNING
  "Error"
  ERROR
}

"Nivel del log para inputs"
enum LogLevelInput {
  "Información"
  INFO
  "Advertencia"
  WARNING
  "Error"
  ERROR
}

"Campos de ordenamiento para logs del sistema"
enum DocumentSysLogSortFieldInput {
  "Por fecha de creación"
  CREATED_AT
  "Por nivel"
  LEVEL
  "Por nombre"
  NAME
}

# ═══════════════════════════════════════════════════════
# ENTIDADES PRINCIPALES
# ═══════════════════════════════════════════════════════

"Clase de documento (nivel 1: Especialidad, Categoría)"
type DocumentClass @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Fecha de última actualización"
  updatedAt: DateTime
  "Usuario que realizó la última actualización"
  updatedBy: UserName!
  "Fecha de deshabilitación"
  terminatedAt: DateTime
  "Indica si es un registro del sistema"
  isSys: Boolean!
  "Nombre de la clase de documento"
  name: String!
  "Código identificador de la clase"
  code: String!
  "Módulo al que pertenece (null = disponible para todos)"
  module: ModuleType
  "Descripción de la clase de documento"
  description: String
  "Orden de visualización"
  sortOrder: Int!
  "Tipos de documento que pertenecen a esta clase"
  documentTypes: [DocumentType!]!
}

"Tipo de documento (Procedimiento, Plano, Informe, etc.)"
type DocumentType @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Fecha de última actualización"
  updatedAt: DateTime
  "Usuario que realizó la última actualización"
  updatedBy: UserName!
  "Fecha de deshabilitación"
  terminatedAt: DateTime
  "Indica si es un registro del sistema"
  isSys: Boolean!
  "Nombre del tipo de documento"
  name: String!
  "Código identificador del tipo"
  code: String!
  "Módulo al que pertenece (null = disponible para todos)"
  module: ModuleType
  "Clase de documento a la que pertenece (null = disponible para todas)"
  class: DocumentClass
  "Descripción del tipo de documento"
  description: String
  "Indica si requiere workflow de aprobación"
  requiresWorkflow: Boolean!
}

"Documento maestro"
type Document @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Usuario que creó el documento"
  createdBy: UserName!
  "Fecha de última actualización"
  updatedAt: DateTime
  "Usuario que realizó la última actualización"
  updatedBy: UserName!
  "Fecha de deshabilitación"
  terminatedAt: DateTime
  "Indica si es un registro del sistema"
  isSys: Boolean!
  "Código único del documento (ej: PR-001)"
  code: String!
  "Título del documento"
  title: String!
  "Descripción del documento"
  description: String
  "Módulo al que pertenece"
  module: ModuleType!
  "Tipo de entidad asociada en el módulo (ej: finding, action)"
  entityType: String
  "ID de la entidad asociada en otro subgraph"
  entityId: Int
  "Tipo de documento"
  documentType: DocumentType!
  "Esquema de revisión actual (ALPHABETICAL o NUMERIC)"
  revisionScheme: RevisionScheme!
  "Revisión vigente del documento"
  currentRevision: DocumentRevision
  "Historial de revisiones del documento"
  revisions: [DocumentRevision!]!
}

"Revisión de un documento"
type DocumentRevision @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Usuario que creó la revisión"
  createdBy: UserName!
  "Fecha de última actualización"
  updatedAt: DateTime
  "Documento al que pertenece la revisión"
  document: Document!
  "Código de la revisión (A, B, C...)"
  revisionCode: String!
  "Estado actual de la revisión"
  status: RevisionStatus!
  "Versiones de archivo de esta revisión"
  versions: [DocumentVersion!]!
  "Versión actual (la más reciente)"
  currentVersion: DocumentVersion
  "Workflow de revisión asociado"
  workflow: ReviewWorkflow
  "Fecha de aprobación"
  approvedAt: DateTime
  "Usuario que aprobó la revisión"
  approvedBy: UserName
}

"Versión de archivo dentro de una revisión"
type DocumentVersion @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Usuario que subió esta versión"
  createdBy: UserName!
  "Revisión a la que pertenece"
  revision: DocumentRevision!
  "Número de versión (1, 2, 3...)"
  versionNumber: Int!
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo"
  fileName: String!
  "Tamaño del archivo en bytes"
  fileSize: Int!
  "Tipo MIME del archivo"
  mimeType: String!
  "Hash SHA-256 para verificación de integridad"
  checksum: String
  "Comentario sobre los cambios de esta versión"
  comment: String
}

# ═══════════════════════════════════════════════════════
# WORKFLOW DE REVISIÓN (ISO 9001)
# ═══════════════════════════════════════════════════════

"Workflow de revisión de un documento"
type ReviewWorkflow @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Revisión asociada al workflow"
  revision: DocumentRevision!
  "Estado actual del workflow"
  status: WorkflowStatus!
  "Pasos del workflow de revisión"
  steps: [ReviewStep!]!
  "Fecha en que se inició el workflow"
  initiatedAt: DateTime!
  "Usuario que inició el workflow"
  initiatedBy: UserName!
  "Fecha de finalización del workflow"
  completedAt: DateTime
}

"Paso individual del workflow de revisión"
type ReviewStep {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Workflow al que pertenece"
  workflow: ReviewWorkflow!
  "Orden de ejecución del paso"
  stepOrder: Int!
  "Tipo de paso (revisión, aprobación, toma de conocimiento)"
  stepType: StepType!
  "Usuario asignado al paso"
  assignedTo: UserName!
  "Estado actual del paso"
  status: StepStatus!
  "Comentarios del evaluador"
  comments: String
  "Fecha de completación del paso"
  completedAt: DateTime
  "Hash de firma para trazabilidad ISO 9001"
  signatureHash: String
}

# ═══════════════════════════════════════════════════════
# TRANSMITTALS (INGENIERÍA)
# ═══════════════════════════════════════════════════════

"Transmittal de ingeniería"
type Transmittal @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Fecha de última actualización"
  updatedAt: DateTime
  "Usuario que realizó la última actualización"
  updatedBy: UserName!
  "Código del transmittal (ej: TR-001)"
  code: String!
  "ID del proyecto asociado"
  projectId: Int!
  "Estado actual del transmittal"
  status: TransmittalStatus!
  "Items incluidos en el transmittal"
  items: [TransmittalItem!]!
  "Destinatario del transmittal"
  issuedTo: String!
  "Fecha de emisión"
  issuedAt: DateTime
  "Usuario que emitió el transmittal"
  issuedBy: UserName!
  "Fecha de respuesta del cliente"
  responseAt: DateTime
  "Comentarios de la respuesta del cliente"
  responseComments: String
}

"Item de un transmittal"
type TransmittalItem {
  "Identificador único"
  id: Int!
  "Transmittal al que pertenece"
  transmittal: Transmittal!
  "Revisión del documento incluida"
  documentRevision: DocumentRevision!
  "Propósito del envío del documento"
  purposeCode: PurposeCode!
  "Estado de respuesta del cliente"
  clientStatus: ClientStatus
  "Comentarios del cliente"
  clientComments: String
}

# ═══════════════════════════════════════════════════════
# ADJUNTOS (Archivos simples sin workflow ni revisiones)
# ═══════════════════════════════════════════════════════

"Adjunto simple (evidencia, foto, archivo de soporte)"
type Attachment @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Usuario que subió el adjunto"
  createdBy: UserName!
  "Módulo al que pertenece"
  module: ModuleType!
  "Tipo de entidad asociada"
  entityType: String!
  "ID de la entidad asociada"
  entityId: Int!
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo"
  fileName: String!
  "Tamaño del archivo en bytes"
  fileSize: Int!
  "Tipo MIME del archivo"
  mimeType: String!
  "Descripción del adjunto"
  description: String
}

# ═══════════════════════════════════════════════════════
# DIGITALIZACIÓN Y CLASIFICACIÓN
# ═══════════════════════════════════════════════════════

"Archivo digitalizado pendiente de clasificación"
type ScannedFile @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación (escaneo/subida)"
  createdAt: DateTime!
  "Usuario que subió el archivo"
  createdBy: UserName!
  "Fecha de última modificación"
  updatedAt: DateTime!
  "Usuario que modificó por última vez"
  updatedBy: UserName!
  "ID del proyecto asociado"
  projectId: Int!
  "Tipo de documento asignado durante clasificación"
  documentType: DocumentType
  "Clase de documento asignada durante clasificación"
  documentClass: DocumentClass
  "Área física o ubicación en planta"
  area: Area
  "Título descriptivo del archivo"
  title: String!
  "Descripción o contexto del archivo físico original"
  description: String
  "Código o referencia del documento original en papel"
  originalReference: String
  "Ubicación física donde se encontró el papel"
  physicalLocation: String
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo digitalizado"
  fileName: String!
  "Tamaño del archivo en bytes"
  fileSize: Int!
  "Tipo MIME del archivo"
  mimeType: String!
  "Estado de clasificación digital"
  digitalDisposition: DigitalDisposition!
  "Disposición del papel físico original"
  physicalDisposition: PhysicalDisposition!
  "Referencia del documento en el sistema externo"
  externalReference: String
  "Enlace completo al documento en el sistema externo"
  externalUrl: String
  "Motivo de descarte (si fue descartado)"
  discardReason: String
  "Notas del clasificador"
  classificationNotes: String
  "Usuario que clasificó el archivo"
  classifiedBy: UserName
  "Fecha de clasificación"
  classifiedAt: DateTime
  "Usuario que confirmó la disposición física"
  physicalConfirmedBy: UserName
  "Fecha de confirmación de la disposición física"
  physicalConfirmedAt: DateTime
  "Fecha de deshabilitación"
  terminatedAt: DateTime
}

"Área física o ubicación en planta"
type Area @key(fields: "id") {
  "Identificador único"
  id: Int!
  "Fecha de creación"
  createdAt: DateTime!
  "Fecha de última actualización"
  updatedAt: DateTime
  "Usuario que realizó la última actualización"
  updatedBy: UserName!
  "Fecha de deshabilitación"
  terminatedAt: DateTime
  "Indica si es un registro del sistema"
  isSys: Boolean!
  "Nombre del área (ej: 01 - Urea)"
  name: String!
  "Código del área (ej: 01)"
  code: String!
  "ID del proyecto al que pertenece"
  projectId: Int!
  "Descripción del área"
  description: String
  "Orden de visualización"
  sortOrder: Int!
}

"Estadísticas de archivos escaneados por estado"
type ScannedFileStats {
  "Total de archivos pendientes de clasificación"
  pending: Int!
  "Total de archivos aceptados pendientes de carga"
  accepted: Int!
  "Total de archivos cargados en sistema externo"
  uploaded: Int!
  "Total de archivos descartados"
  discarded: Int!
  "Total general"
  total: Int!
  "Papel pendiente de decisión"
  physicalPending: Int!
  "Papel programado para destrucción"
  physicalDestroy: Int!
  "Papel con destrucción confirmada"
  physicalDestroyed: Int!
  "Papel programado para almacenamiento"
  physicalArchive: Int!
  "Papel con almacenamiento confirmado"
  physicalArchived: Int!
}

# ═══════════════════════════════════════════════════════
# LOGS
# ═══════════════════════════════════════════════════════

"Registro de log del sistema"
type DocumentSysLog {
  "Identificador único del log"
  id: Int!
  "Fecha de creación del log"
  createdAt: DateTime!
  "Usuario que generó el log"
  user: UserName
  "Nivel de severidad del log"
  level: LogLevel!
  "Nombre del log"
  name: String
  "Mensaje del log"
  message: String!
  "Metadatos adicionales del log"
  meta: String
}

"Logs archivados del sistema"
type DocumentSysLogArchive {
  "Identificador único del log archivado"
  id: Int!
  "Fecha de creación del log archivado"
  createdAt: DateTime!
  "Usuario que generó el log archivado"
  user: UserName
  "Nivel de severidad del log archivado"
  level: LogLevel!
  "Nombre del log archivado"
  name: String
  "Mensaje del log archivado"
  message: String!
  "Metadatos adicionales del log archivado"
  meta: String
}

# ═══════════════════════════════════════════════════════
# PAGINACIÓN
# ═══════════════════════════════════════════════════════

"Información de paginación"
type PaginationInfo @shareable {
  "Página actual"
  currentPage: Int! @shareable
  "Total de páginas"
  totalPages: Int! @shareable
  "Total de elementos"
  totalItems: Int! @shareable
  "Indica si hay una página siguiente"
  hasNext: Boolean! @shareable
  "Indica si hay una página anterior"
  hasPrev: Boolean! @shareable
}

"Respuesta paginada de documentos"
type DocumentConnection {
  "Documentos en la página actual"
  items: [Document!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de tipos de documento"
type DocumentTypeConnection {
  "Tipos de documento en la página actual"
  items: [DocumentType!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de clases de documento"
type DocumentClassConnection {
  "Clases de documento en la página actual"
  items: [DocumentClass!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de transmittals"
type TransmittalConnection {
  "Transmittals en la página actual"
  items: [Transmittal!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de logs"
type DocumentSysLogConnection {
  "Logs del sistema en la página actual"
  items: [DocumentSysLog!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de logs archivados"
type DocumentSysLogArchiveConnection {
  "Logs archivados en la página actual"
  items: [DocumentSysLogArchive!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de adjuntos"
type AttachmentConnection {
  "Adjuntos en la página actual"
  items: [Attachment!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de áreas"
type AreaConnection {
  "Áreas en la página actual"
  items: [Area!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Respuesta paginada de archivos escaneados"
type ScannedFileConnection {
  "Archivos escaneados en la página actual"
  items: [ScannedFile!]!
  "Información de paginación"
  pagination: PaginationInfo!
}

"Lista de selección"
type SelectList @shareable {
  "Etiqueta para mostrar en la selección"
  label: String! @shareable
  "Valor para enviar en la selección"
  value: String! @shareable
}

# ═══════════════════════════════════════════════════════
# INPUTS
# ═══════════════════════════════════════════════════════

"Input para paginación"
input PaginationInput {
  "Número de elementos a omitir"
  skip: Int = 0
  "Número de elementos a tomar"
  take: Int = 10
}

"Filtro de documentos"
input DocumentFilterInput {
  "Búsqueda en code + title"
  query: String
  "Filtrar por módulo"
  module: ModuleTypeInput
  "Filtrar por tipo de documento"
  documentTypeId: Int
  "Filtra por status de revisión vigente"
  status: RevisionStatusInput
  "Filtrar por estado de habilitación"
  terminatedFilter: TerminatedFilterInput
}

"Ordenamiento de documentos"
input DocumentOrderByInput {
  "Campo por el cual ordenar"
  field: DocumentOrderFieldInput!
  "Dirección del ordenamiento"
  direction: SortDirectionInput!
}

"Filtro de tipos de documento"
input DocumentTypeFilterInput {
  "Búsqueda en nombre o código"
  query: String
  "Filtrar por módulo"
  module: ModuleTypeInput
  "Filtrar por clase de documento"
  classId: Int
  "Filtrar por estado de habilitación"
  terminatedFilter: TerminatedFilterInput
}

"Ordenamiento de tipos de documento"
input DocumentTypeOrderByInput {
  "Campo por el cual ordenar"
  field: DocumentTypeOrderFieldInput!
  "Dirección del ordenamiento"
  direction: SortDirectionInput!
}

"Filtro de clases de documento"
input DocumentClassFilterInput {
  "Búsqueda en nombre o código"
  query: String
  "Filtrar por módulo"
  module: ModuleTypeInput
  "Filtrar por estado de habilitación"
  terminatedFilter: TerminatedFilterInput
}

"Ordenamiento de clases de documento"
input DocumentClassOrderByInput {
  "Campo por el cual ordenar"
  field: DocumentClassOrderFieldInput!
  "Dirección del ordenamiento"
  direction: SortDirectionInput!
}

"Campos de ordenamiento para clases de documento"
enum DocumentClassOrderFieldInput {
  "Por nombre"
  NAME
  "Por código"
  CODE
  "Por orden"
  SORT_ORDER
  "Por fecha de creación"
  CREATED_AT
}

"Filtro de transmittals"
input TransmittalFilterInput {
  "Búsqueda en código o destinatario"
  query: String
  "Filtrar por proyecto"
  projectId: Int
  "Filtrar por estado"
  status: TransmittalStatusInput
}

"Filtro de áreas"
input AreaFilterInput {
  "Búsqueda en nombre o código"
  query: String
  "Filtrar por proyecto"
  projectId: Int
  "Filtrar por estado de habilitación"
  terminatedFilter: TerminatedFilterInput
}

"Ordenamiento de áreas"
input AreaOrderByInput {
  "Campo por el cual ordenar"
  field: AreaOrderFieldInput!
  "Dirección del ordenamiento"
  direction: SortDirectionInput!
}

"Campos de ordenamiento para áreas"
enum AreaOrderFieldInput {
  "Por nombre"
  NAME
  "Por código"
  CODE
  "Por orden"
  SORT_ORDER
  "Por fecha de creación"
  CREATED_AT
}

"Ordenamiento de transmittals"
input TransmittalOrderByInput {
  "Campo por el cual ordenar"
  field: TransmittalOrderFieldInput!
  "Dirección del ordenamiento"
  direction: SortDirectionInput!
}

"Input para crear un documento"
input CreateDocumentInput {
  "Código único del documento"
  code: String!
  "Título del documento"
  title: String!
  "Descripción del documento"
  description: String
  "Módulo al que pertenece"
  module: ModuleTypeInput!
  "Tipo de entidad asociada"
  entityType: String
  "ID de la entidad asociada"
  entityId: Int
  "ID del tipo de documento"
  documentTypeId: Int!
  "Esquema de revisión inicial (por defecto ALPHABETICAL)"
  revisionScheme: RevisionSchemeInput
  "Código de revisión inicial (por defecto 'A' para ALPHABETICAL o '0' para NUMERIC)"
  initialRevisionCode: String
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo"
  fileName: String!
  "Tamaño del archivo en bytes"
  fileSize: Int!
  "Tipo MIME del archivo"
  mimeType: String!
  "Hash SHA-256 para verificación de integridad"
  checksum: String
}

"Input para actualizar un documento"
input UpdateDocumentInput {
  "Nuevo título del documento"
  title: String
  "Nueva descripción del documento"
  description: String
}

"Input para crear una revisión"
input CreateRevisionInput {
  "Código de revisión (auto-generado si no se provee)"
  revisionCode: String
  "Comentario sobre la revisión"
  comment: String
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo"
  fileName: String!
  "Tamaño del archivo en bytes"
  fileSize: Int!
  "Tipo MIME del archivo"
  mimeType: String!
  "Hash SHA-256 para verificación de integridad"
  checksum: String
}

"Input para registrar una nueva versión de archivo"
input RegisterVersionInput {
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo"
  fileName: String!
  "Tamaño del archivo en bytes"
  fileSize: Int!
  "Tipo MIME del archivo"
  mimeType: String!
  "Hash SHA-256 para verificación de integridad"
  checksum: String
  "Comentario sobre los cambios de esta versión"
  comment: String
}

"Input para iniciar un workflow de revisión"
input InitiateReviewInput {
  "Pasos del workflow a crear"
  steps: [ReviewStepInput!]!
}

"Input para un paso del workflow"
input ReviewStepInput {
  "Orden de ejecución del paso"
  stepOrder: Int!
  "Tipo de paso"
  stepType: StepTypeInput!
  "ID del usuario asignado"
  assignedToId: Int!
}

"Input para crear un tipo de documento"
input CreateDocumentTypeInput {
  "Nombre del tipo de documento"
  name: String!
  "Código identificador"
  code: String!
  "Módulo al que pertenece"
  module: ModuleTypeInput
  "Clase de documento a la que pertenece"
  classId: Int
  "Descripción del tipo"
  description: String
  "Indica si requiere workflow de aprobación"
  requiresWorkflow: Boolean
}

"Input para actualizar un tipo de documento"
input UpdateDocumentTypeInput {
  "Nuevo nombre del tipo"
  name: String
  "Nuevo código identificador"
  code: String
  "Nuevo módulo al que pertenece"
  module: ModuleTypeInput
  "Nueva clase de documento"
  classId: Int
  "Nueva descripción"
  description: String
  "Indica si requiere workflow"
  requiresWorkflow: Boolean
}

"Input para crear una clase de documento"
input CreateDocumentClassInput {
  "Nombre de la clase de documento"
  name: String!
  "Código identificador"
  code: String!
  "Módulo al que pertenece"
  module: ModuleTypeInput
  "Descripción de la clase"
  description: String
  "Orden de visualización"
  sortOrder: Int
}

"Input para actualizar una clase de documento"
input UpdateDocumentClassInput {
  "Nuevo nombre de la clase"
  name: String
  "Nuevo código identificador"
  code: String
  "Nuevo módulo al que pertenece"
  module: ModuleTypeInput
  "Nueva descripción"
  description: String
  "Nuevo orden de visualización"
  sortOrder: Int
}

"Input para crear un transmittal"
input CreateTransmittalInput {
  "ID del proyecto asociado"
  projectId: Int!
  "Nombre del destinatario"
  issuedTo: String!
  "Items a incluir en el transmittal"
  items: [TransmittalItemInput!]!
}

"Input para crear un área"
input CreateAreaInput {
  "Nombre del área"
  name: String!
  "Código del área"
  code: String!
  "ID del proyecto"
  projectId: Int!
  "Descripción del área"
  description: String
  "Orden de visualización"
  sortOrder: Int
}

"Input para actualizar un área"
input UpdateAreaInput {
  "Nuevo nombre del área"
  name: String
  "Nuevo código del área"
  code: String
  "Nueva descripción"
  description: String
  "Nuevo orden de visualización"
  sortOrder: Int
}

"Input de item para transmittal"
input TransmittalItemInput {
  "ID de la revisión del documento a incluir"
  documentRevisionId: Int!
  "Propósito del envío"
  purposeCode: PurposeCodeInput!
}

"Input para responder un transmittal"
input RespondTransmittalInput {
  "Comentarios generales de la respuesta"
  responseComments: String
  "Respuestas por cada item"
  items: [TransmittalItemResponseInput!]!
}

"Input de respuesta por item del transmittal"
input TransmittalItemResponseInput {
  "ID del item del transmittal"
  itemId: Int!
  "Estado de respuesta del cliente"
  clientStatus: ClientStatusInput!
  "Comentarios del cliente para este item"
  clientComments: String
}

"Input para crear un adjunto"
input CreateAttachmentInput {
  "Módulo al que pertenece"
  module: ModuleTypeInput!
  "Tipo de entidad asociada"
  entityType: String!
  "ID de la entidad asociada"
  entityId: Int!
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo"
  fileName: String!
  "Tamaño del archivo en bytes"
  fileSize: Int!
  "Tipo MIME del archivo"
  mimeType: String!
  "Descripción del adjunto"
  description: String
}

"Filtro de archivos escaneados"
input ScannedFileFilterInput {
  "Búsqueda por título, referencia original o referencia externa"
  query: String
  "Filtrar por proyecto"
  projectId: Int
  "Filtrar por tipo de documento"
  documentTypeId: Int
  "Filtrar por clase de documento"
  documentClassId: Int
  "Filtrar por área"
  areaId: Int
  "Filtrar por disposición digital"
  digitalDisposition: DigitalDispositionInput
  "Filtrar por disposición física"
  physicalDisposition: PhysicalDispositionInput
  "Filtrar por estado de habilitación"
  terminatedFilter: TerminatedFilterInput
}

"Ordenamiento de archivos escaneados"
input ScannedFileOrderByInput {
  "Campo por el cual ordenar"
  field: ScannedFileOrderFieldInput!
  "Dirección del ordenamiento"
  direction: SortDirectionInput!
}

"Datos para subir un archivo escaneado"
input CreateScannedFileInput {
  "ID del proyecto"
  projectId: Int!
  "Título descriptivo"
  title: String!
  "Descripción o contexto"
  description: String
  "Código o referencia del documento original en papel"
  originalReference: String
  "Ubicación física donde se encontró"
  physicalLocation: String
  "ID del área física o ubicación en planta"
  areaId: Int
  "Key del archivo en DO Spaces"
  fileKey: String!
  "Nombre original del archivo"
  fileName: String!
  "Tamaño en bytes"
  fileSize: Int!
  "Tipo MIME"
  mimeType: String!
}

"Datos para clasificar un archivo escaneado"
input ClassifyScannedFileInput {
  "Disposición digital: ACCEPTED o DISCARDED"
  digitalDisposition: DigitalDispositionInput!
  "ID del tipo de documento (requerido si ACCEPTED)"
  documentTypeId: Int
  "ID de la clase de documento"
  documentClassId: Int
  "ID del área"
  areaId: Int
  "Notas de clasificación"
  classificationNotes: String
  "Motivo de descarte (requerido si DISCARDED)"
  discardReason: String
}

"Datos para marcar como cargado en sistema externo"
input MarkAsUploadedInput {
  "Referencia del documento en el sistema externo"
  externalReference: String!
}

"Filtro de logs del sistema"
input DocumentSysLogFilterInput {
  "Buscar en mensaje o nombre"
  query: String
  "Filtrar por usuario"
  userId: Int
  "Filtrar por nivel"
  level: LogLevelInput
  "Fecha desde"
  createdFrom: DateTime
  "Fecha hasta"
  createdTo: DateTime
}

"Input para ordenamiento de logs del sistema"
input DocumentSysLogOrderByInput {
  "Campo por el cual ordenar"
  field: DocumentSysLogSortFieldInput!
  "Dirección del ordenamiento"
  direction: SortDirectionInput! = ASC
}

# ═══════════════════════════════════════════════════════
# QUERIES
# ═══════════════════════════════════════════════════════

type Query {
  # ─── Documentos ───
  "Obtener un documento por ID"
  documentById(id: Int!): Document

  "Listar documentos con filtro, paginación y ordenamiento"
  documents(
    filter: DocumentFilterInput
    pagination: PaginationInput
    orderBy: DocumentOrderByInput
  ): DocumentConnection!

  "Documentos filtrados por referencia de módulo"
  documentsByModule(
    module: ModuleTypeInput!
    entityType: String
    entityId: Int
    pagination: PaginationInput
    orderBy: DocumentOrderByInput
  ): DocumentConnection!

  "Listado de documentos para selectores"
  documentsSelectList(filter: DocumentFilterInput): [SelectList!]!

  # ─── Tipos de documento ───
  "Listar tipos de documento"
  documentTypes(
    filter: DocumentTypeFilterInput
    pagination: PaginationInput
    orderBy: DocumentTypeOrderByInput
  ): DocumentTypeConnection!

  "Obtener un tipo de documento por ID"
  documentTypeById(id: Int!): DocumentType

  "Listado de tipos de documento para selectores"
  documentTypesSelectList(module: ModuleTypeInput, classId: Int): [SelectList!]!

  # ─── Clases de documento ───
  "Listar clases de documento"
  documentClasses(
    filter: DocumentClassFilterInput
    pagination: PaginationInput
    orderBy: DocumentClassOrderByInput
  ): DocumentClassConnection!

  "Obtener una clase de documento por ID"
  documentClassById(id: Int!): DocumentClass

  "Listado de clases de documento para selectores"
  documentClassesSelectList(module: ModuleTypeInput): [SelectList!]!

  # ─── Áreas ───
  "Listar áreas"
  areas(
    filter: AreaFilterInput
    pagination: PaginationInput
    orderBy: AreaOrderByInput
  ): AreaConnection!

  "Obtener un área por ID"
  areaById(id: Int!): Area

  "Listado de áreas para selectores"
  areasSelectList(projectId: Int!): [SelectList!]!

  # ─── Revisiones ───
  "Obtener una revisión por ID"
  revisionById(id: Int!): DocumentRevision

  # ─── Transmittals ───
  "Obtener un transmittal por ID"
  transmittalById(id: Int!): Transmittal

  "Listar transmittals con filtro, paginación y ordenamiento"
  transmittals(
    filter: TransmittalFilterInput
    pagination: PaginationInput
    orderBy: TransmittalOrderByInput
  ): TransmittalConnection!

  "Transmittals de un proyecto específico"
  transmittalsByProject(
    projectId: Int!
    pagination: PaginationInput
  ): TransmittalConnection!

  # ─── Workflows ───
  "Steps de revisión pendientes para un usuario"
  pendingReviewSteps(userId: Int!): [ReviewStep!]!

  "Workflows filtrados por estado"
  workflowsByStatus(status: WorkflowStatusInput!): [ReviewWorkflow!]!

  # ─── Adjuntos ───
  "Obtener un adjunto por ID"
  attachmentById(id: Int!): Attachment

  "Listar adjuntos por referencia de módulo"
  attachmentsByModule(
    module: ModuleTypeInput!
    entityType: String!
    entityId: Int!
    pagination: PaginationInput
  ): AttachmentConnection!

  # ─── Logs del Sistema ───
  "Obtiene un log del sistema por su identificador"
  documentSysLogById(id: Int!): DocumentSysLog

  "Obtiene una lista paginada de logs del sistema"
  documentSysLogs(
    filter: DocumentSysLogFilterInput
    pagination: PaginationInput
    orderBy: DocumentSysLogOrderByInput
  ): DocumentSysLogConnection!

  # ─── Logs Archivados del Sistema ───
  "Obtiene un log archivado del sistema por su identificador"
  documentSysLogArchiveById(id: Int!): DocumentSysLogArchive

  "Obtiene una lista paginada de logs archivados del sistema"
  documentSysLogsArchive(
    filter: DocumentSysLogFilterInput
    pagination: PaginationInput
    orderBy: DocumentSysLogOrderByInput
  ): DocumentSysLogArchiveConnection!
}

# ═══════════════════════════════════════════════════════
# MUTATIONS
# ═══════════════════════════════════════════════════════

type Mutation {
  # ─── Documentos ───
  "Crear un nuevo documento con su primera revisión y versión"
  createDocument(input: CreateDocumentInput!): Document!

  "Actualizar metadata de un documento"
  updateDocument(id: Int!, input: UpdateDocumentInput!): Document!

  "Eliminar un documento (soft delete)"
  terminateDocument(id: Int!): Document!

  "Reactivar un documento"
  activateDocument(id: Int!): Document!

  "Cambiar el esquema de revisión de un documento (ej: de ALPHABETICAL a NUMERIC)"
  switchRevisionScheme(
    "ID del documento"
    id: Int!
    "Nuevo esquema de revisión"
    scheme: RevisionSchemeInput!
  ): Document!

  # ─── Revisiones ───
  "Crear una nueva revisión para un documento"
  createRevision(
    documentId: Int!
    input: CreateRevisionInput!
  ): DocumentRevision!

  # ─── Versiones ───
  "Registrar una nueva versión de archivo en una revisión"
  registerVersion(
    revisionId: Int!
    input: RegisterVersionInput!
  ): DocumentVersion!

  # ─── Workflow de revisión ───
  "Iniciar un workflow de revisión para una revisión"
  initiateReview(revisionId: Int!, input: InitiateReviewInput!): ReviewWorkflow!

  "Aprobar un paso del workflow"
  approveStep(stepId: Int!, comments: String): ReviewStep!

  "Rechazar un paso del workflow"
  rejectStep(stepId: Int!, comments: String!): ReviewStep!

  "Cancelar un workflow de revisión"
  cancelWorkflow(workflowId: Int!, reason: String!): ReviewWorkflow!

  # ─── Transmittals ───
  "Crear un nuevo transmittal"
  createTransmittal(input: CreateTransmittalInput!): Transmittal!

  "Emitir un transmittal (cambiar a ISSUED)"
  issueTransmittal(id: Int!): Transmittal!

  "Registrar respuesta del cliente en un transmittal"
  respondTransmittal(id: Int!, input: RespondTransmittalInput!): Transmittal!

  "Cerrar un transmittal"
  closeTransmittal(id: Int!): Transmittal!

  # ─── Tipos de documento ───
  "Crear un tipo de documento"
  createDocumentType(input: CreateDocumentTypeInput!): DocumentType!

  "Actualizar un tipo de documento"
  updateDocumentType(id: Int!, input: UpdateDocumentTypeInput!): DocumentType!

  "Deshabilitar un tipo de documento"
  terminateDocumentType(id: Int!): DocumentType!

  "Reactivar un tipo de documento"
  activateDocumentType(id: Int!): DocumentType!

  # ─── Clases de documento ───
  "Crear una clase de documento"
  createDocumentClass(input: CreateDocumentClassInput!): DocumentClass!

  "Actualizar una clase de documento"
  updateDocumentClass(id: Int!, input: UpdateDocumentClassInput!): DocumentClass!

  "Deshabilitar una clase de documento"
  terminateDocumentClass(id: Int!): DocumentClass!

  "Reactivar una clase de documento"
  activateDocumentClass(id: Int!): DocumentClass!

  # ─── Áreas ───
  "Crear un área"
  createArea(input: CreateAreaInput!): Area!

  "Actualizar un área"
  updateArea(id: Int!, input: UpdateAreaInput!): Area!

  "Deshabilitar un área"
  terminateArea(id: Int!): Area!

  "Reactivar un área"
  activateArea(id: Int!): Area!

  # ─── Adjuntos ───
  "Crear un nuevo adjunto"
  createAttachment(input: CreateAttachmentInput!): Attachment!

  "Eliminar un adjunto"
  deleteAttachment(id: Int!): Boolean!

  # ─── Archivos escaneados ───
  "Subir un archivo escaneado"
  createScannedFile(input: CreateScannedFileInput!): ScannedFile!

  "Clasificar un archivo escaneado (ACCEPTED o DISCARDED)"
  classifyScannedFile(id: Int!, input: ClassifyScannedFileInput!): ScannedFile!

  "Marcar archivo como cargado en sistema externo"
  markAsUploaded(id: Int!, input: MarkAsUploadedInput!): ScannedFile!

  "Actualizar disposición física del papel"
  updatePhysicalDisposition(id: Int!, disposition: PhysicalDispositionInput!): ScannedFile!

  "Confirmar ejecución de la disposición física (DESTROY→DESTROYED, ARCHIVE→ARCHIVED)"
  confirmPhysicalDisposition(id: Int!): ScannedFile!

  "Dar de baja un archivo escaneado"
  terminateScannedFile(id: Int!): ScannedFile!

  "Reactivar un archivo escaneado"
  activateScannedFile(id: Int!): ScannedFile!

  # ─── Logs del Sistema ───
  "Archiva logs del sistema antiguos (mueve de DocumentSysLog a DocumentSysLogArchive)"
  archiveDocumentSysLogs(olderThanDays: Int!): Int!

  "Elimina logs archivados antiguos permanentemente"
  deleteArchivedDocumentSysLogs(olderThanDays: Int!): Int!
}
